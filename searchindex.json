{"categories":[{"title":"Data Oriented Design","uri":"https://dotsplayground.com/categories/data-oriented-design/"},{"title":"dots","uri":"https://dotsplayground.com/categories/dots/"},{"title":"ecs","uri":"https://dotsplayground.com/categories/ecs/"},{"title":"unity","uri":"https://dotsplayground.com/categories/unity/"}],"posts":[{"content":"Introduction Knowing how the Unity editor can support you while developing with DOTS is important to speed up the workflow and get debugging information. In this post I will go over what editor features are available for DOTS.\nTo follow along with this post you will needed the following packages.\n Entities: Installing this package and its dependencies will add everything needed to develop with DOTS, such as the burst compiler and job system. DOTS Editor: While optional, this package will add extra editor features for DOTS which will be covered here.  Entity Debugger Can be found under: Window \u0026gt; Analysis \u0026gt; Entity Debugger\n  The entity debugger gives information about the state of the world. It can show you which entities exist, what components they contain, which systems are running on them and which chunks are used. We will go over each part of the entity debugger.\n1. World selection:\nAllows you to select the world to show the containing entities and systems of. You can select Show Full Player Loop to show all worlds and Show Inactive Systems to also show systems that are not running.\n2. System details:\nThis section will allow you to view all system groups and the systems they contain. Notice that systems are listed in order of execution.\nFor each system it gives useful performance information in milliseconds spend on the main thread. You can also disable individual systems to prevent them from running. Selecting a system will show you the entities and components the system runs on, and allows you to view chunk information.\n3. Entity inspector:\nThis shows you all the entities that match the specified system query.\nNotice that components are colored based on read only, read write or subtractive (can not contain), but expect this to be expanded on in the future as currently not all query types have a color code.\nSelecting an entity will show you its component values in the inspector, shown here in the image on the right.\n4. Chunk info:\nChunks in DOTS can be very confusing at first, so to properly explain this section I will first give an simplified explanation of chunks. A chunk is a pre-allocated 16kB block of memory, which has an archetype that defines which components are in the chunk. Based on this the chunk calculates how many entities of this archetype it can hold. When entities are added they are put in the chunk until its full at which point a new chunk is created.\nThe chunk info section shows you how many archetypes match a system query and how many chunks each archetype has. At the bottom it than shows how full these chunks are in a histogram.\n  In this image we match 1 archetype which has 3 chunks. A chunk of this archetype can hold 104 entities. 2 chunks are currently full (bar on the right) and 1 chunk holds 13 entities (bar on the left).\nLive Link Mode Can be found under: DOTS \u0026gt; Live Link Mode\n  Live link allows to convert to DOTS while in edit mode. For live link to work you need to add your objects in a subscene: Hierarchy \u0026gt; Right click \u0026gt; New SubScene From Selection. Selecting an object in the subscene will you its ECS components, and the object can now be found in the entity debugger. Keeping the subscene open during play mode will now also allow you to make changes to the entity without restarting.\nThere are two scene view modes for live link. SceneView: Live Game State makes the scene view show the final converted result in edit mode turning the scene into a hybrid rendered scene. SceneView: Editing State will instead keep the editor renderer and not apply the full conversion. This mode will renderer gizmos, but any changes to the entity that happen at conversion will not be applied.\nBurst Inspector Can be found under: Jobs \u0026gt; Burst \u0026gt; Open Inspector...\n  The burst inspector is a useful tool for low level performance optimizations. Most people will not be able or need to read the compiler output. However the LLVM Optimization Diagnostics can still be interesting to look at. It gives compiler info in a more human readable manner, which can be used to for instance check if your code is getting vectorized.\n  Here you can see that the compiler marked line 35 as unable to vectorize.\n  After a change in the code line 35 is marked as vectorized.\nDOTS Compiler Can be found under: DOTS \u0026gt; DOTS Compiler \u0026gt; Open Inspector...\n  The DOTS Compiler can show DOTS generated code. This means its able to show you the code generated when using the [GenerateAuthoringComponent] tag.\nOthers To further control the compilation process you can enable and disable multiple setting having to do with debugging and safety under Jobs. These speak for themselves so I will not be going in depth any further.\n  To speed up the load time when pressing play in the editor, you can disable scene and domain reload under: Edit \u0026gt; Player Settings \u0026gt; Editor \u0026gt; Enter Play Mode Settings. This is not directly connected to DOTS in any way. But its main downsides largely do not apply to DOTS code, while still giving you the benefits of improved speed. For more information see the documentation.\n","id":0,"section":"posts","summary":"Introduction Knowing how the Unity editor can support you while developing with DOTS is important to speed up the workflow and get debugging information. In this post I will go over what editor features are available for DOTS.\nTo follow along with this post you will needed the following packages.\n Entities: Installing this package and its dependencies will add everything needed to develop with DOTS, such as the burst compiler and job system.","tags":["dots","ecs","csharp","beginner"],"title":"Unity DOTS Editor","uri":"https://dotsplayground.com/2020/02/dotseditor/","year":"2020"},{"content":"How can we implement interaction between entities? Before we can actually answer that question, we should formulate the actual problem.\nSummary There are two problems in an ECS when it comes to interaction between entities: read and write access. The truth is that interactions do not really exists, they hide the implementation of the underlaying relationship. A relationship is then nothing else than the transformation of data. (More about)\nTo reason about the right tool for creating those transformations, we need to reason about our code and ask ourselves the following five questions:\n What data do we operate on? What is our domain? What is the possible input for our transformation. What is the frequentcy of the data use? What are we actually transfroming? How could our algorithm look like? How often do we perfrom our transfromation?  For infrequent read access we can easily use the ComponentDataFromEntity structure. It allows us array like access to the underlying data. It’s not recommended to use this structure for read access because in this case we give up the guaranteed safety of the C# Job System in a multithreaded environment.\nWhen it comes to write access we should consider to make use of the EnityCommandBuffer. This is a great tool to collect a bunch of commands (actions) we want to perform. The buffer can be invoked immediately or deferred, depending on our needs. In the case of SystemGroups we can use our own CommandBuffer or we can use one of the default ones.\nFor more details follow the rest of this post.\nThe problem When creating interactions between entities we mainly face 2 types of problems:\n  Read Access: Concrete this means we have to read certain properties from a particular entity (object) and react based on this. In terms of games: An Actor needs to query / know some information from another part of the game. For example within a Quest System: Have all tasks been completed?\n  Write access: Concrete this means we have to write certain properties to an particular entity (object).\n  Transformation from Interaction towards Relationships In order to start this transformation we should have a quick look at the first principle of Data Oriented Design:\n Data is not the problem domain. For some, it would seem that data-oriented design is the antithesis of most other programming paradigms because data-oriented design is a technique that does not readily allow the problem domain to enter into the software so readily. It does not recognize the concept of an object in any way, as data is consistently without meaning [\u0026hellip;] The data-oriented design approach doesn’t build the real world problem into the code. This could be seen as a failing of the data oriented approach by veteran object-oriented developers, as many examples of the success of object-oriented design come from being able to bring the human concepts to the machine, then in this middle ground, a solution can be written in this language that is understandable by both human and computer. The data-oriented approach gives up some of the human readability by leaving the problem domain in the design document, but stops the machine from having to handle human concepts at any level by just that same action — Data Orinted Design Book Chapter 1.2\n This helps us to recognize that interactions do not really exists, they hide the implementation of the underlaying relationship. A relationship is nothing else then a transformation of data. In case of an ECS the Entity Manager can be seen as a database and the Entity as a Lookup table key which indexes relationships between components. The systems are just here to interpret those relationships and give them meaning. Therefore, a system should only do one job and do this well. Systems perform transformations of data. This allows us to create generic systems which are decoupled and easy to reuse and as such, we should keep the following in mind:\n One of the main design goals for Data Oriented Design driven application is to focus on reusability through decoupling whenever possible. Thus the Unix philosophy Write programs that do one thing and do it well. Write programs to work together — McIlroy is a good way of expressing what a system should do.\n DOTS or any ECS is built with the idea of relationships in mind. When we are writing systems, we transform data from one state to another to give the data meaning. Therefore systems are defining the meaning of the data relationships. This decoupling gives us the flexibility we need to design complex software such as video games. This allows us to modify the behavior later on, without breaking any dependencies.\nHow do we design Systems? To implement the aforementioned relationships, we have to under take a couple of steps. We have to ask the following questions:\n1. What data transformations are we going to do and on which data?This question should lead to “what components do we need to create this relationship?” We should always be able to give a reason why we need this data.\n2. What is our possible domain? (What kind of inputs do we have?)\nWhen we figure this out, we are able to make the right decision later on and can reason about our code how we implement the relationship?\n3. How often does the data change?To determine how often we change the data, we go through component by component and discuss how often we change it. This is important to pick the right tool later. Knowing those numbers or tendencies is great for reasoning about possible performance bottlenecks and where we could apply optimizations.\n4. What are we actually transforming?\nWriting down the algorithm or the constraints of what we are actually doing with our data is a great solution. In order to pick the right tool based on the planned algorithm, we need to consider the cost of our algorithm.\nWhat does cost mean? It can mean anything from runtime costs to implementation cost. It is important to first establish what the right criteria are. The costs at the end enables us to reason about the code.\nTo pick the right tool, we need to be able to reason about the costs an algorithm costs us. In some case if we take run time performance as measurement it is okay to have a slow algorithm if we do not execute this frequently but if this is not the case another solution should be considered.\n5. How often do we execute the algorithm / transformation?\nBased on the information we have by defining what data we need for the transformation, it’s quite easy to define the frequency of execution. The total number of entities / objects is known at the time of judgment therefore we can guess how often this might run. Besides this, we have discussed how often we are suspecting the data to be changed, which leads to a transparency, which gives a good idea of the costs of this code.\nIMPORTANT: When the data changes, the problem changes. Therefore, we have to properly evaluate with the descriptive method the possible outcome and maybe change the implementation.\nRead Access (ComponentDataFromEntity) In case its required to read from a certain entity, ComponentDataFromEntity is the right tool. This tool allows us to read a specified type (component) of an entity. It is a native container that provides array-like access to components of a specific type, therefore we can easily read the data we need from it. It is a powerful tool to access component data from entities but on the other hand it allows random access and is therefore slow.\nIMPORTANT:\n You can safely read from ComponentDataFromEntity in any Job, but by default, you cannot write to components in the container in parallel Jobs (including IJobForEach\u0026lt;T0\u0026gt; and IJobChunk). If you know that two instances of a parallel Job can never write to the same index in the container, you can disable the restriction on parallel writing by adding NativeDisableParallelForRestrictionAttribute to the ComponentDataFromEntity field definition in the Job struct.\nUnity Documentation\n Example:\n//... code [BurstCompile] struct MyJob : IJobForEach\u0026lt;MyCmp,Position\u0026gt;{ [ReadOnly] public ComponentDataFromEntity\u0026lt;Position\u0026gt; data; public void Execute([ReadOnly] ref MyCmp mycmp, [ReadOnly] ref Position pos){ if(!data.Exists(mycmp.Entity)) return; Position mycmppos = data[mycmp.Entity]; //... do some magic  } } ///... protected override JobHandle OnUpdate(...){ var job = new MyJob(){ GetComponentDataFromEntity\u0026lt;Position\u0026gt;(true) // true = read only!  } //... } Write Access (EntityCommandBuffer) The right tool for changing data (write access) in the ECS is it to make use of the EntityCommandBuffer, in case of an infrequent change of data. In a different context, a more value driven approach (direct change) might be more appropriate. The Buffer allows us to cache commands and they will be then executed afterwards. If the context is working in a multithreaded environment it’s important to let the ``EntityCommandBufferto know about this. This will be done via thisEntityCommandBuffer.Concurrent`.\n//... code [BurstCompile] struct MyJob : IJobForEach\u0026lt;Target\u0026gt;{ public EntityCommandBuffer.Concurrent buffer; public void Execute(Entity entity, int index,[ReadOnly] ref Target target){ buffer.AddComponent(index,target.Enity,typeof(...)); } } Important to realize here is that nothing happens till the moment Playback() gets called. It depends on our needs if we want to invoke this immediately after we have created the buffer and filled or deferred through Unity’s default Buffers. Then we need to keep the sync points of a game in mind. We have 3 system groups: InitializationSystemGroup SimulationSystemGroup and PresentationSystemGroup. If we do not specify where we want to add our CommandBuffer, our command buffer will be automatically added to the SimulationSystemGroup. It is possible to create your own.\n//...Code protected override OnCreate(...){ m_buffer = world.GetOrCreateSystem\u0026lt;InitializationEntityCommandBufferSystem\u0026gt;(); } protected override JobHandle OnUpdate(...){ var job = new MyJob(){ buffer = m_buffer.CreateCommandBuffer().ToConcurrent() }.Schedule(this,inputDepends); m_buffer.AddJobHandleForProducer(job); return job; } Brief Overview of SystemGroups (Default)  InitializationSystemGroup (updated at the end of the nitialization phase of the player loop) SimulationSystemGroup (updated at the end of the Update phase of the player loop) PresentationSystemGroup (updated at the end of the PreLateUpdate phase of the player loop)  All of those groups provide 2 command buffers e.g. BeginPresentationEntityCommandBufferSystem and EndPresentationEntityCommandBufferSystem. This can be used to determine when we want to execute what.\nReferences This page is mainly based on the following Unity talk: Options for Entity interaction - Unite Copenhagen   ","id":1,"section":"posts","summary":"How can we implement interaction between entities? Before we can actually answer that question, we should formulate the actual problem.\nSummary There are two problems in an ECS when it comes to interaction between entities: read and write access. The truth is that interactions do not really exists, they hide the implementation of the underlaying relationship. A relationship is then nothing else than the transformation of data. (More about)\nTo reason about the right tool for creating those transformations, we need to reason about our code and ask ourselves the following five questions:","tags":["esc","DOTS","software engineering","dod","data oriented design","ComponentDataFromEntity"],"title":"How Entites could interact","uri":"https://dotsplayground.com/2019/11/entityinteraction/","year":"2019"},{"content":"The problem Often in games different objects interact with each other, eg. a button opens a door, a child follows its parent etc. With the new ESC system those hierarchies aren\u0026rsquo;t trivial, hierarchies don\u0026rsquo;t really exist natively. So how do we link entities in a hierarchy?\nLinking entities as a group In the new ESC if you translate a GameObject via ConvertToEntity to entities the hierarchy would not be translated into the ESC World. The simple solution to this is called LinkedEntityGroup. This translates the hierarchy to ESC land.\nLinkedEntityGroup is a Buffer which can be used to link the lifetime of entities together. This buffer takes an entity as reference point (root) and when this one gets destroyed all the linked entities get destroyed as well.\nThe following example demonstrates the usage of the LinkedEntityGroup:\npublic class LinkedEntityGroupComponent: MonoBehaviour, IConvertGameObjectToEntity { public void Convert (Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem) { var buffer = dstManager.AddBuffer \u0026lt;LinkedEntityGroup\u0026gt; (entity); var children = transform.GetComponentsInChildren \u0026lt;Transform\u0026gt; (); foreach (var child in children) { var childEntity = conversionSystem.GetPrimaryEntity (child.gameObject); buffer.Add (childEntity); } } } ","id":2,"section":"posts","summary":"The problem Often in games different objects interact with each other, eg. a button opens a door, a child follows its parent etc. With the new ESC system those hierarchies aren\u0026rsquo;t trivial, hierarchies don\u0026rsquo;t really exist natively. So how do we link entities in a hierarchy?\nLinking entities as a group In the new ESC if you translate a GameObject via ConvertToEntity to entities the hierarchy would not be translated into the ESC World.","tags":["dots","ecs","csharp","reference","relation","hybrid"],"title":"Linking entities or entity relationships","uri":"https://dotsplayground.com/2019/11/linkingentities/","year":"2019"}],"tags":[{"title":"beginner","uri":"https://dotsplayground.com/tags/beginner/"},{"title":"ComponentDataFromEntity","uri":"https://dotsplayground.com/tags/componentdatafromentity/"},{"title":"csharp","uri":"https://dotsplayground.com/tags/csharp/"},{"title":"data oriented design","uri":"https://dotsplayground.com/tags/data-oriented-design/"},{"title":"dod","uri":"https://dotsplayground.com/tags/dod/"},{"title":"dots","uri":"https://dotsplayground.com/tags/dots/"},{"title":"ecs","uri":"https://dotsplayground.com/tags/ecs/"},{"title":"esc","uri":"https://dotsplayground.com/tags/esc/"},{"title":"hybrid","uri":"https://dotsplayground.com/tags/hybrid/"},{"title":"reference","uri":"https://dotsplayground.com/tags/reference/"},{"title":"relation","uri":"https://dotsplayground.com/tags/relation/"},{"title":"software engineering","uri":"https://dotsplayground.com/tags/software-engineering/"}]}